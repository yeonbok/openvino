#!/usr/bin/python3
# Copyright (C) 2018-2021 Intel Corporation
# SPDX-License-Identifier: Apache-2.0
# To add new kernel please add a .cl file to kernels directory
# the database name will be the part of the file name up to first '.' character
# the trailing characters are a tag to allow multiple primitive implementations

from __future__ import print_function
import os
import argparse
import glob
import ntpath
import re

class OpenCL2CHeaders(object):

    def __init__(self, kernels_folder, out_path, out_file_name):
        self.kernels_folder = os.path.abspath(kernels_folder)
        self.out_path = os.path.abspath(out_path)
        self.out_file_name = out_file_name
        self.include_files = {}
        self.batch_headers = []
        self.find_and_set_batch_headers()

    def find_and_set_batch_headers(self):
        batch_headers_list = [ntpath.basename(h) for h in glob.glob(os.path.join(self.kernels_folder, "include/batch_headers/*.cl"))]
        deps = {}
        for h in batch_headers_list:
            header_file = os.path.abspath(os.path.join(self.kernels_folder, "include/batch_headers", h))
            f = open(header_file)
            content = f.readlines()
            deps[h] = {h}
            for line in content:
                if line.startswith('#include'):
                    include_file_name = line.strip().split('"')[1].strip()
                    deps[h].add(include_file_name)
                else:
                    continue
        self.batch_headers = self.topological_sort(deps)

    def topological_sort(self, items):
        visited = set()
        stack = []
        res = []
        cur_key = next(iter(items))
        cur_deps = items[cur_key]
        items.pop(cur_key)
        stack += [cur_key] + [ dep for dep in cur_deps]
        while stack or items:
            if not stack:
                cur_key = next(iter(items))
                cur_deps = items[cur_key]
                stack += [cur_key] + [ dep for dep in cur_deps if dep not in res]
                items.pop(cur_key)
            else:
                cur_key = stack[-1]
                if cur_key in res:
                    stack.pop()
                    continue
                if cur_key not in items.keys():
                    res.append(cur_key)
                    stack.pop()
                else:
                    cur_deps = [dep for dep in items[cur_key] if dep not in stack and dep not in res]
                    if not cur_deps:
                        res.append(cur_key)
                        stack.pop()
                    else:
                        stack += cur_deps
        return res

    def convert(self):
        res = '// This file is autogenerated by primitive_db_gen.py, all changes to this file will be undone\n\n'
        filelist = glob.glob(os.path.join(self.kernels_folder, "*.cl"))
        for filename in filelist:
            #try:
                print('processing {}'.format(filename))
                res += self.cl_file_to_str(filename)
            #except:
            #    pass
        out_file_name = os.path.join(self.out_path, self.out_file_name)
        with open(out_file_name, 'w') as out_file:
            out_file.write(res)

        # write batch_header_str
        res = self.batch_headers_to_str()
        out_file_name = os.path.join(self.out_path, "ks_primitive_db_batch_headers.inc")
        with open(out_file_name, 'w') as out_file:
            out_file.write(res)

    def append_undefs(self, filename):
        undefs = ""
        content = []
        with open(filename) as f:
            content += f.readlines()
        for line in content:
            if '#define' in line:
                name = line.strip().split(" ")[1].split("(")[0]
                undefs += "#ifdef " + name + "\n"
                undefs += "#undef " + name + "\n"
                undefs += "#endif\n"
            if '# define' in line:
                name = line.strip().split(" ")[2].split("(")[0]
                undefs += "#ifdef " + name + "\n"
                undefs += "#undef " + name + "\n"
                undefs += "#endif\n"
        if filename in self.include_files:
            for include_file in self.include_files[filename]:
                include_file_undefs = self.append_undefs(include_file)
                undefs += include_file_undefs
        return undefs

    def find_concat_user(self, words, start_idx, macro):
        potential_macro_user_exist = False
        concat_len = 0
        iter_idx = start_idx
        len_str1 = len_str2 = 0
        if words[iter_idx + 2] == "CAT":
            user_exist, len_str1 = self.find_concat_user(words, iter_idx + 2, macro)
            potential_macro_user_exist |= user_exist
        else:
            if macro.find(words[iter_idx + 2]) >= 0 :
                potential_macro_user_exist = True
            len_str1 = 1

        if words[iter_idx + 3 + len_str1] == "CAT":
            user_exist, len_str2 = self.find_concat_user(words, iter_idx + 3, macro)
            potential_macro_user_exist |= user_exist
        else:
            if macro.find(words[iter_idx + 3 + len_str1]) >= 0:
                potential_macro_user_exist = True
            len_str2 = 1
        return potential_macro_user_exist, (len_str1 + len_str2 + 4)

    def found_macro_user(self, macro, start_idx, contents_list):
        for line in contents_list[start_idx : -1]:
            if line.find(macro) > 0:
                return True
            if line.find("CAT") > 0:
                words = ' '.join(re.split("(\W)", line)).split()
                iter_w = 0
                cat_hit = 0
                while iter_w < len(words):
                    if cat_hit == 0 and words[iter_w]  != "CAT":
                        iter_w += 1
                        continue
                    user_exist, concat_len = self.find_concat_user(words, iter_w, macro)
                    if user_exist:
                        return True
                    iter_w += concat_len
        return False

    def reduce_macros(self, contents):
        new_contents = ""
        contents_list = contents.split("\n")
        idx = 0
        while idx < len(contents_list):
            line = contents_list[idx]
            is_macro = re.search('#\s*define', line)
            macro = ""
            if is_macro:
                words = ' '.join(re.split("(\W)", line)).split()
                macro = words[2]

            if len(macro) == 0 or self.found_macro_user(macro, idx + 1, contents_list):
                new_contents += (line.rstrip() + "\n")
                idx += 1
            else:
                if line.rstrip()[-1] == '\\':
                    while contents_list[idx].rstrip()[-1] == '\\':
                            idx += 1
                idx += 1
        return new_contents

    def append_file_content(self, filename, origin_file):
        res = ""
        new_content = []
        content = []
        with open(filename) as f:
            content += f.readlines()

        for line in content:
            if line.startswith('#include'):
                include_file_name = line.strip().split('"')[1].strip()
                if ntpath.basename(include_file_name) in self.batch_headers:
                    continue
                full_path_include = os.path.abspath(os.path.join(os.path.dirname(filename), include_file_name))
                if full_path_include not in self.include_files[origin_file]:
                    self.include_files[origin_file][full_path_include] = True
                    res += self.append_file_content(full_path_include, origin_file)
                    res += "\n"
                continue
            res += '{}\n'.format(line.rstrip())
        if filename == origin_file:
            return self.reduce_macros(res)
        else:
            return res

    def batch_headers_to_str(self):
        res = '(std::string) R"(\n'
        for h in self.batch_headers:
            header_file = os.path.abspath(os.path.join(os.path.dirname(self.kernels_folder + "/include/batch_headers"), "batch_headers/" + h))
            content = []
            with open(header_file) as f:
                content += f.readlines()
            for line in content:
                if line.startswith('#include'):
                    continue
                res += '{}\n'.format(line.rstrip())
        res += ')"\n\n'
        return res

    def cl_file_to_str(self, filename):
        name = ntpath.basename(filename)
        self.include_files[filename] = {}
        kernel_name = name[:name.find('.cl')]
        res = '{{"{}",\n(std::string) R"__krnl(\n'.format(kernel_name)
        content = self.append_file_content(filename, filename)
        content += self.append_undefs(filename)
        max_lines = 200
        max_characters = 16350
        characters = 1  # Newline character above

        comment_regexp = re.compile(r'(^)?[^\S\n]*/(?:\*(.*?)\*/[^\S\n]*|/[^\n]*)($)?', re.DOTALL | re.MULTILINE)

        def comment_replacer(match):
            begin, mid, end = match.group(1,2,3)
            if mid is None:
                return ''
            elif begin is not None or end is not None:
                return ''
            elif '\n' in mid:
                return '\n'
            else:
                return ' '

            return

        # Remove comments
        content = comment_regexp.sub(comment_replacer, content)
        # Remove empty lines
        content = os.linesep.join([s for s in content.splitlines() if s])
        # Remove multiple spaces
        content = re.sub(' +', ' ', content)
        for i, line in enumerate(content.split('\n')):
            if (i + 1) % max_lines == 0 or characters + len(line) + 1 > max_characters:
                res += ')__krnl"\n + R"__krnl('
                characters = 0
            res += line + '\n'
            characters += len(line) + 1

        res += ')__krnl"}},\n\n'.format(kernel_name)

        return res


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('-kernels', required=True, metavar='PATH', help='The absolute path to OpenCL kernels folder')
    ap.add_argument('-out_path', required=True, metavar='PATH', help='The absolute path to dump file')
    ap.add_argument('-out_file_name', required=True, metavar='PATH', help='dump file name')
    args = ap.parse_args()

    converter = OpenCL2CHeaders(args.kernels, args.out_path, args.out_file_name)
    converter.convert()

if __name__ == '__main__':
    main()
